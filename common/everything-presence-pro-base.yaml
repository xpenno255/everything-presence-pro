esphome:
  project:
    name: EverythingSmartTechnology.Everything Presence Pro
    version: "1.1.2"
  on_boot:
    - priority: 500 
      then:
        - delay: 200ms
        - switch.turn_on: system_alarm_relay
        # Start loading animation and keep it until API connects
        - lambda: 'id(api_connected_flag) = false;'
        - light.turn_on:
            id: led_rgb
            brightness: 25%
            red: 100%
            green: 80%
            blue: 0%
            white: 0%
            effect: "Network Connecting"

globals:
  - id: api_connected_flag
    type: bool
    restore_value: no
    initial_value: 'false'

# Enable logging
logger:

# Enable Home Assistant API
api:
  on_client_connected:
    then:
      - if:
          condition:
            lambda: 'return id(led_mode_select).state != "Manual Control";'
          then:
            - lambda: 'id(api_connected_flag) = true;'
            # Multi-color celebration, then restore mode
            - light.turn_off: led_rgb
            - delay: 50ms
            - light.turn_on:
                id: led_rgb
                brightness: 70%
                red: 0%
                green: 100%
                blue: 100%
                white: 0%
            - delay: 250ms
            - light.turn_on:
                id: led_rgb
                brightness: 70%
                red: 0%
                green: 60%
                blue: 100%
                white: 0%
            - delay: 250ms
            - light.turn_on:
                id: led_rgb
                brightness: 70%
                red: 60%
                green: 0%
                blue: 100%
                white: 0%
            - delay: 250ms
            - light.turn_on:
                id: led_rgb
                brightness: 70%
                red: 100%
                green: 0%
                blue: 80%
                white: 0%
            - delay: 250ms
            - light.turn_on:
                id: led_rgb
                brightness: 65%
                red: 100%
                green: 100%
                blue: 100%
                white: 0%
            - delay: 350ms
            - script.execute: update_led_state

  on_client_disconnected:
    then:
      - if:
          condition:
            lambda: 'return id(led_mode_select).state != "Manual Control";'
          then:
            - lambda: 'id(api_connected_flag) = false;'
            - light.turn_on:
                id: led_rgb
                effect: "API Disconnected"

http_request:
  verify_ssl: false
  timeout: 30s

ota:
  - platform: esphome
  - platform: http_request
    id: ota_http_request

debug:
  update_interval: 5s

text_sensor:
  - platform: debug
    device:
      name: "Device Info"
      entity_category: diagnostic
    reset_reason:
      name: "Reset Reason"
      entity_category: diagnostic

sensor:
  - platform: shtcx
    id: "shtc3_sensor"
    i2c_id: bus_a
    temperature:
      name: Temperature
      id: temperature_sensor
      filters:
        - lambda: "return x + id(env_temperature_offset).state;"
    humidity:
      name: Humidity
      id: humidity_sensor
      filters:
        - lambda: "return x + id(env_humidity_offset).state;"
    address: 0x70
    update_interval: 2s
  
  - platform: bh1750
    name: Illuminance
    id: illuminance_sensor
    i2c_id: bus_a
    address: 0x23
    update_interval: 2s
    filters:
      - lambda: "return x + id(env_illuminance_offset).state;"
      - clamp:
          min_value: 0

i2c:
  - id: bus_a
    scl: GPIO32
    sda: GPIO33
    scan: true

binary_sensor:
  - platform: gpio
    name: Motion
    id: pir_motion
    device_class: motion
    pin:
      number: GPIO36
    filters:
      - delayed_off:  !lambda 'return id(pir_off_delay).state * 1000.0;'
    on_state:
      then:
        - lambda: |-
            auto mode = id(system_alarm_mode).state;
            if (mode == "Motion Only" || mode == "Motion or Presence") {
              if (id(pir_motion).state) {
                id(system_alarm_relay).turn_on();
              } else {
                id(system_alarm_relay).turn_off();
              }
            }

  - platform: template
    name: Occupancy
    id: occupancy
    device_class: occupancy
    filters:
      - delayed_off: !lambda 'return id(occupancy_off_delay).state * 1000.0;'
    lambda: |-
      if ( id(dfrobot_presence).state or id(pir_motion).state) {
        return true;
      }
      else if (id(dfrobot_presence).state == 0 and id(pir_motion).state == 0) {
        return false;
      }
      else {
        return id(ld2450_occupancy).state;
      }
    on_state:
      then:
        - lambda: |-
            auto mode = id(system_alarm_mode).state;
            if (mode == "Presence Only" || mode == "Motion or Presence") {
              if (id(occupancy).state) {
                id(system_alarm_relay).turn_on();
              } else {
                id(system_alarm_relay).turn_off();
              }
            }
        - if:
            condition:
              lambda: 'return id(led_mode_select).state == "Presence";'
            then:
              - if:
                  condition:
                    lambda: 'return id(occupancy).state;'
                  then:
                    - light.turn_on:
                        id: led_rgb
                        brightness: 50%
                        red: 0%
                        green: 100%
                        blue: 100%
                        white: 0%
                        effect: "Presence Glow"
                  else:
                    - light.turn_off: led_rgb

  - platform: template
    name: mmWave Presence
    id: mmwave_occupancy
    device_class: occupancy
    filters:
      - delayed_off: !lambda 'return id(occupancy_off_delay).state * 1000.0;'
    lambda: |-
      return id(dfrobot_presence).state || id(ld2450_occupancy).state;

light:
  - platform: esp32_rmt_led_strip
    id: led_rgb
    rgb_order: GRB
    pin:
      number: GPIO2
      ignore_strapping_warning: true
    num_leds: 1
    chipset: sk6812
    name: "LED"
    effects:
      - pulse:
          name: "Pulse"
          transition_length: 1s
          update_interval: 1s
      - pulse:
          name: "Environmental Pulse"
          transition_length: 2s
          update_interval: 2s
      - pulse:
          name: "Presence Glow"
          transition_length: 800ms
          update_interval: 800ms
          min_brightness: 10%
          max_brightness: 70%
      - pulse:
          name: "Network Connecting"
          transition_length: 800ms
          update_interval: 800ms
          min_brightness: 35%
          max_brightness: 75%
      # API connection status effect
      - strobe:
          name: "API Disconnected"
          colors:
            - state: true
              brightness: 15%
              red: 100%
              green: 0%
              blue: 100%
              white: 0%
              duration: 400ms
            - state: false
              duration: 3000ms

select:
  - platform: template
    name: Relay Trigger Mode
    id: system_alarm_mode
    entity_category: config
    optimistic: True
    options:
      - "Disabled"
      - "Motion Only"
      - "Presence Only"
      - "Motion or Presence"
    initial_option: "Disabled"
    restore_value: true
    on_value:
      then:
        - lambda: |-
            auto mode = id(system_alarm_mode).state;

            if (mode == "Disabled") {
              id(system_alarm_relay).turn_off();
            }
            else if (mode == "Motion Only") {
              if (id(pir_motion).state) {
                id(system_alarm_relay).turn_on();
              } else {
                id(system_alarm_relay).turn_off();
              }
            }
            else if (mode == "Presence Only") {
              if (id(occupancy).state) {
                id(system_alarm_relay).turn_on();
              } else {
                id(system_alarm_relay).turn_off();
              }
            }
            else if (mode == "Motion or Presence") {
              if (id(pir_motion).state || id(occupancy).state) {
                id(system_alarm_relay).turn_on();
              } else {
                id(system_alarm_relay).turn_off();
              }
            }

  - platform: template
    name: "LED Mode"
    id: led_mode_select
    entity_category: config
    optimistic: true
    options:
      - "Manual Control"
      - "Environmental"
      - "Presence"
    initial_option: "Manual Control"
    restore_value: true
    icon: mdi:led-variant
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(led_mode_select).state == "Manual Control";'
            then:
              - logger.log: "Setting LED to Manual Control mode"
              - light.turn_off: led_rgb
        
        - if:
            condition:
              lambda: 'return id(led_mode_select).state == "Environmental";'
            then:
              - logger.log: "Setting LED to Environmental mode"
              - script.execute: update_environmental_led
        
        - if:
            condition:
              lambda: 'return id(led_mode_select).state == "Presence";'
            then:
              - logger.log: "Setting LED to Presence mode"
              - light.turn_off: led_rgb

  - platform: template
    id: firmware_network
    name: Network Type
    icon: "mdi:network"
    entity_category: diagnostic
    optimistic: true
    restore_value: true
    options:
      - "WiFi"
      - "Ethernet"
    initial_option: "Ethernet"

  - platform: template
    id: firmware_co2
    name: CO2 Sensor
    icon: "mdi:molecule-co2"
    entity_category: diagnostic
    optimistic: true
    restore_value: true
    options:
      - "Disabled"
      - "Enabled"
    initial_option: "Disabled"

  - platform: template
    id: firmware_ble
    name: Bluetooth Proxy
    icon: "mdi:bluetooth"
    entity_category: diagnostic
    optimistic: true
    restore_value: true
    options:
      - "Disabled"
      - "Enabled"
    initial_option: "Disabled"

script:
  - id: update_led_state
    then:
      - if:
          condition:
            lambda: 'return id(led_mode_select).state == "Manual Control";'
          then:
            - logger.log: "Setting LED to Manual Control mode"
            - light.turn_off: led_rgb
      
      - if:
          condition:
            lambda: 'return id(led_mode_select).state == "Environmental";'
          then:
            - logger.log: "Setting LED to Environmental mode"
            - script.execute: update_environmental_led
      
      - if:
          condition:
            lambda: 'return id(led_mode_select).state == "Presence";'
          then:
            - logger.log: "Setting LED to Presence mode"
            - light.turn_off: led_rgb

  - id: update_environmental_led
    then:
      - light.turn_on:
          id: led_rgb
          brightness: 20%
          red: 0%
          green: 80%
          blue: 20%
          white: 0%
          effect: "Environmental Pulse"

switch:
  - platform: gpio
    name: "Relay Output"
    id: system_alarm_relay
    pin:
      number: GPIO12
      inverted: false
      ignore_strapping_warning: true

number:
  - platform: template
    name: Occupancy Timeout
    icon: mdi:clock-end
    entity_category: config
    id: occupancy_off_delay
    min_value: 1
    max_value: 600
    initial_value: 15
    optimistic: true
    step: 5
    restore_value: true
    unit_of_measurement: seconds
    mode: slider

  - platform: template
    name: Motion Timeout
    icon: mdi:clock-end
    entity_category: config
    id: pir_off_delay
    min_value: 1
    max_value: 120
    initial_value: 10
    optimistic: true
    step: 1
    restore_value: true
    unit_of_measurement: seconds
    mode: slider

  - platform: template
    name: "Temperature Calibration"
    id: env_temperature_offset
    unit_of_measurement: "Â°C"
    min_value: -20
    max_value: 20
    step: 0.1
    mode: box
    update_interval: never
    optimistic: true
    restore_value: true
    initial_value: 0
    icon: "mdi:thermometer"
    entity_category: config
    on_value:
      - lambda: 'id(shtc3_sensor).update();'

  - platform: template
    name: "Humidity Calibration"
    id: env_humidity_offset
    unit_of_measurement: "%"
    min_value: -50
    max_value: 50
    step: 0.1
    mode: box
    update_interval: never
    optimistic: true
    restore_value: true
    initial_value: 0
    icon: "mdi:water-percent"
    entity_category: config
    on_value:
      - lambda: 'id(shtc3_sensor).update();'

  - platform: template
    name: "Illuminance Calibration"
    id: env_illuminance_offset
    unit_of_measurement: "lx"
    min_value: -50
    max_value: 50
    step: 1
    mode: box
    update_interval: never
    optimistic: true
    restore_value: true
    initial_value: 0
    icon: "mdi:brightness-5"
    entity_category: config
    on_value:
      - lambda: 'id(illuminance_sensor).update();'

button:
  - platform: restart
    name: "Restart Device"
    entity_category: config

  - platform: template
    name: "Apply Update"
    entity_category: diagnostic
    on_press:
      - logger.log: "Applying firmware update based on selected configuration"
      - lambda: |-
          // Build manifest URL based on selected options
          std::string base_url = "https://docs.everythingsmart.io/update/everything-presence-pro/everything-presence-pro-";

          // Add network type (required, lowercase)
          std::string network = id(firmware_network).state;
          std::transform(network.begin(), network.end(), network.begin(), ::tolower);
          base_url += network;

          // Add features in alphabetical order (ble before co2)
          if (id(firmware_ble).state == "Enabled") {
            base_url += "-ble";
          }

          if (id(firmware_co2).state == "Enabled") {
            base_url += "-co2";
          }

          base_url += "-manifest.json";

          ESP_LOGI("firmware", "Switching to manifest: %s", base_url.c_str());
          id(update_http_request).set_source_url(base_url.c_str());
      - component.update: update_http_request
      - delay: 2s
      - update.perform:
          id: update_http_request
          force_update: true
